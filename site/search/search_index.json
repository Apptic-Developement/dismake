{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dismake","text":"<p>Dismake is a powerful Discord HTTP interactions API wrapper designed for Python developers. Whether you're using Flask, Django, or any other Python web framework, Dismake has you covered.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Framework Independent: Dismake supports all Python web frameworks, ensuring flexibility in your project.</li> <li>Command Handler Included: Take advantage of Dismake's built-in command handler for streamlined bot development.</li> <li>Active Community Support: Join our vibrant community for help, discussions, and updates.</li> <li>CLI for Project Generation: Use our CLI tool to kickstart your projects with ease.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Explore the extensive documentation to get started with Dismake:</p> <ul> <li>Installation</li> <li>Quick Start Guide</li> <li>API Reference</li> <li>Examples</li> </ul>"},{"location":"#join-the-community","title":"Join the Community","text":"<p>Have questions or need assistance? Join our community:</p> <ul> <li>Discord Server</li> <li>GitHub Repository</li> </ul> <p>Start building awesome Discord bots with Dismake today!</p>"},{"location":"api/client/","title":"Client","text":""},{"location":"api/client/#dismake.client.Client","title":"Client","text":"<p>Represents a client for interacting with the Discord API.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The token of the bot.</p> required <code>application_id</code> <code>int</code> <p>The ID of the application that the bot is associated with.</p> required <code>public_key</code> <code>str</code> <p>The public key of the application.</p> required <p>Attributes:</p> Name Type Description <code>http</code> <code>HttpClient</code> <p>The HTTP client that will be used to make requests to Discord.</p> Source code in <code>dismake/client.py</code> <pre><code>class Client:\n\"\"\"Represents a client for interacting with the Discord API.\n\n    Parameters\n    -----------\n    token: str\n        The token of the bot.\n    application_id: int\n        The ID of the application that the bot is associated with.\n    public_key: str\n        The public key of the application.\n\n    Attributes\n    ----------\n    http: HttpClient\n        The HTTP client that will be used to make requests to Discord.\n    \"\"\"\n\n    def __init__(\n        self,\n        token: str,\n        application_id: int,\n        public_key: str,\n    ) -&gt; None:\n        self.http: HttpClient = HttpClient(token=token, application_id=application_id)\n        self._verify_key = VerifyKey(key=bytes.fromhex(public_key))\n        self.__events: Dict[str, List[AsyncFunction]] = {}\n\n    def verify(self, signature: str, timestamp: str, body: bytes) -&gt; bool:\n\"\"\"Verify the incoming signature from Discord.\n\n        Parameters\n        ----------\n        signature: str\n            The signature from Discord.\n        timestamp: str\n            The timestamp from Discord.\n        body: bytes\n            The body of the request from Discord.\n\n        Returns\n        -------\n        bool\n            True if the signature is valid, False otherwise.\n        \"\"\"\n        try:\n            self._verify_key.verify(\n                smessage=timestamp.encode() + body, signature=bytes.fromhex(signature)\n            )\n        except BadSignatureError:\n            return False\n        else:\n            return True\n\n    async def parse_interaction_create(self, data: InteractionData) -&gt; None:\n\"\"\"Parse and execute the appropriate action for an incoming interaction.\n\n        Parameters\n        ----------\n        data: InteractionData\n            The incoming interaction data.\n        \"\"\"\n        interaction = Interaction(client=self, data=data)\n\n        if interaction.is_application_command:\n            ...\n        if interaction.is_message_component:\n            ...\n        if interaction.is_modal_submit:\n            ...\n</code></pre>"},{"location":"api/client/#dismake.client.Client.parse_interaction_create","title":"parse_interaction_create  <code>async</code>","text":"<pre><code>parse_interaction_create(data: InteractionData) -&gt; None\n</code></pre> <p>Parse and execute the appropriate action for an incoming interaction.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>InteractionData</code> <p>The incoming interaction data.</p> required Source code in <code>dismake/client.py</code> <pre><code>async def parse_interaction_create(self, data: InteractionData) -&gt; None:\n\"\"\"Parse and execute the appropriate action for an incoming interaction.\n\n    Parameters\n    ----------\n    data: InteractionData\n        The incoming interaction data.\n    \"\"\"\n    interaction = Interaction(client=self, data=data)\n\n    if interaction.is_application_command:\n        ...\n    if interaction.is_message_component:\n        ...\n    if interaction.is_modal_submit:\n        ...\n</code></pre>"},{"location":"api/client/#dismake.client.Client.verify","title":"verify","text":"<pre><code>verify(signature: str, timestamp: str, body: bytes) -&gt; bool\n</code></pre> <p>Verify the incoming signature from Discord.</p> <p>Parameters:</p> Name Type Description Default <code>signature</code> <code>str</code> <p>The signature from Discord.</p> required <code>timestamp</code> <code>str</code> <p>The timestamp from Discord.</p> required <code>body</code> <code>bytes</code> <p>The body of the request from Discord.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the signature is valid, False otherwise.</p> Source code in <code>dismake/client.py</code> <pre><code>def verify(self, signature: str, timestamp: str, body: bytes) -&gt; bool:\n\"\"\"Verify the incoming signature from Discord.\n\n    Parameters\n    ----------\n    signature: str\n        The signature from Discord.\n    timestamp: str\n        The timestamp from Discord.\n    body: bytes\n        The body of the request from Discord.\n\n    Returns\n    -------\n    bool\n        True if the signature is valid, False otherwise.\n    \"\"\"\n    try:\n        self._verify_key.verify(\n            smessage=timestamp.encode() + body, signature=bytes.fromhex(signature)\n        )\n    except BadSignatureError:\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"api/models/asset/","title":"Asset","text":""},{"location":"api/models/asset/#dismake.models.asset.Asset","title":"Asset","text":"<p>Represents a CDN asset on Discord.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The url of the asset.</p> required <code>hash</code> <code>str</code> <p>The hash of the asset.</p> required <code>animated</code> <code>bool</code> <p>Wheather this asset is animated.</p> required"},{"location":"api/models/asset/#dismake.models.asset.Asset--operations","title":"Operations","text":"<ul> <li><code>str(x)</code>:     Returns the CDN URL of the asset.</li> <li><code>len(x)</code>:     Checks the length of the asset's URL.</li> <li><code>repr(x)</code>:     Returns a string representation of the asset.</li> <li><code>x == y</code>:     Checks if two Asset instances are equal.</li> <li><code>x != y</code>:     Checks if two Asset instances are not equal.</li> </ul> Source code in <code>dismake/models/asset.py</code> <pre><code>class Asset:\n\"\"\"Represents a CDN asset on Discord.\n\n    Parameters\n    ----------\n    url: str\n        The url of the asset.\n    hash: str\n        The hash of the asset.\n    animated: bool\n        Wheather this asset is animated.\n\n    Operations\n    ----------\n    - ``str(x)``:\n        Returns the CDN URL of the asset.\n    - ``len(x)``:\n        Checks the length of the asset's URL.\n    - ``repr(x)``:\n        Returns a string representation of the asset.\n    - ``x == y``:\n        Checks if two Asset instances are equal.\n    - ``x != y``:\n        Checks if two Asset instances are not equal.\n\n    \"\"\"\n\n    def __init__(self, url: str, hash: str, animated: bool) -&gt; None:\n        self._url = url\n        self._hash = hash\n        self._animated = animated\n\n    @classmethod\n    def from_default_avatar(cls, index: int) -&gt; Self:\n        return cls(\n            url=f\"{BASE_URL}/embed/avatars/{index}.png\",\n            hash=str(index),\n            animated=False,\n        )\n\n    @classmethod\n    def from_avatar(cls, user_id: int, avatar: str) -&gt; Self:\n        animated = avatar.startswith(\"a_\")\n        format = \"gif\" if animated else \"png\"\n        return cls(\n            url=f\"{BASE_URL}/avatars/{user_id}/{avatar}.{format}?size=1024\",\n            hash=avatar,\n            animated=animated,\n        )\n\n    @classmethod\n    def from_guild_avatar(cls, guild_id: int, member_id: int, avatar: str) -&gt; Self:\n        animated = avatar.startswith(\"a_\")\n        format = \"gif\" if animated else \"png\"\n        return cls(\n            url=f\"{BASE_URL}/guilds/{guild_id}/users/{member_id}/avatars/{avatar}.{format}?size=1024\",\n            hash=avatar,\n            animated=animated,\n        )\n\n    @classmethod\n    def from_icon(cls, object_id: int, icon_hash: str, path: str) -&gt; Self:\n        return cls(\n            url=f\"{BASE_URL}/{path}-icons/{object_id}/{icon_hash}.png?size=1024\",\n            hash=icon_hash,\n            animated=False,\n        )\n\n    @classmethod\n    def from_app_icon(\n        cls, object_id: int, icon_hash: str, asset_type: Literal[\"icon\", \"cover_image\"]\n    ) -&gt; Self:\n        return cls(\n            url=f\"{BASE_URL}/app-icons/{object_id}/{asset_type}.png?size=1024\",\n            hash=icon_hash,\n            animated=False,\n        )\n\n    @classmethod\n    def from_cover_image(cls, object_id: int, cover_image_hash: str) -&gt; Self:\n        return cls(\n            url=f\"{BASE_URL}/app-assets/{object_id}/store/{cover_image_hash}.png?size=1024\",\n            hash=cover_image_hash,\n            animated=False,\n        )\n\n    @classmethod\n    def from_scheduled_event_cover_image(\n        cls, scheduled_event_id: int, cover_image_hash: str\n    ) -&gt; Self:\n        return cls(\n            url=f\"{BASE_URL}/guild-events/{scheduled_event_id}/{cover_image_hash}.png?size=1024\",\n            hash=cover_image_hash,\n            animated=False,\n        )\n\n    @classmethod\n    def from_guild_image(cls, guild_id: int, image: str, path: str) -&gt; Self:\n        animated = image.startswith(\"a_\")\n        format = \"gif\" if animated else \"png\"\n        return cls(\n            url=f\"{BASE_URL}/{path}/{guild_id}/{image}.{format}?size=1024\",\n            hash=image,\n            animated=animated,\n        )\n\n    @classmethod\n    def from_guild_icon(cls, guild_id: int, icon_hash: str) -&gt; Self:\n        animated = icon_hash.startswith(\"a_\")\n        format = \"gif\" if animated else \"png\"\n        return cls(\n            url=f\"{BASE_URL}/icons/{guild_id}/{icon_hash}.{format}?size=1024\",\n            hash=icon_hash,\n            animated=animated,\n        )\n\n    @classmethod\n    def from_sticker_banner(cls, banner: int) -&gt; Self:\n        return cls(\n            url=f\"{BASE_URL}/app-assets/710982414301790216/store/{banner}.png\",\n            hash=str(banner),\n            animated=False,\n        )\n\n    @classmethod\n    def from_user_banner(cls, user_id: int, banner_hash: str) -&gt; Self:\n        animated = banner_hash.startswith(\"a_\")\n        format = \"gif\" if animated else \"png\"\n        return cls(\n            url=f\"{BASE_URL}/banners/{user_id}/{banner_hash}.{format}?size=512\",\n            hash=banner_hash,\n            animated=animated,\n        )\n\n    def __str__(self) -&gt; str:\n        return self._url\n\n    def __len__(self) -&gt; int:\n        return len(self._url)\n\n    def __repr__(self) -&gt; str:\n        shorten = self._url.replace(BASE_URL, \"\")\n        return f\"&lt;Asset url={shorten!r}&gt;\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        return isinstance(other, Asset) and self._url == other._url\n\n    def __hash__(self) -&gt; int:\n        return hash(self._url)\n\n    @property\n    def url(self) -&gt; str:\n\"\"\"Returns the underlying URL of the asset.\"\"\"\n        return self._url\n\n    @property\n    def hash(self) -&gt; str:\n\"\"\"Returns the identifying hash of the asset.\"\"\"\n        return self._hash\n\n    @property\n    def is_animated(self) -&gt; bool:\n\"\"\"Returns whether the asset is animated.\"\"\"\n        return self._animated\n</code></pre>"},{"location":"api/models/asset/#dismake.models.asset.Asset.hash","title":"hash  <code>property</code>","text":"<pre><code>hash: str\n</code></pre> <p>Returns the identifying hash of the asset.</p>"},{"location":"api/models/asset/#dismake.models.asset.Asset.is_animated","title":"is_animated  <code>property</code>","text":"<pre><code>is_animated: bool\n</code></pre> <p>Returns whether the asset is animated.</p>"},{"location":"api/models/asset/#dismake.models.asset.Asset.url","title":"url  <code>property</code>","text":"<pre><code>url: str\n</code></pre> <p>Returns the underlying URL of the asset.</p>"},{"location":"api/models/color/","title":"Color","text":""},{"location":"api/models/color/#dismake.models.color.Color","title":"Color","text":"<p>Represents a Discord role colour. This class is similar to a (red, green, blue).</p> <p>There is an alias for this called Colour.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>int</code> <p>The raw integer color value.</p>"},{"location":"api/models/color/#dismake.models.color.Color--operations","title":"Operations","text":"<ul> <li> <p><code>x == y</code>:     Checks if two colors are equal.</p> </li> <li> <p><code>x != y</code>:     Checks if two colors are not equal.</p> </li> <li> <p><code>str(x)</code>:     Returns the hex format for the colour.</p> </li> <li> <p><code>hash(x)</code>:     Return the color's hash.</p> </li> <li> <p><code>int(x)</code>:     Returns the raw color value.</p> </li> </ul> Source code in <code>dismake/models/color.py</code> <pre><code>class Color:\n\"\"\"Represents a Discord role colour. This class is similar\n    to a (red, green, blue).\n\n    There is an alias for this called Colour.\n    Attributes\n    ----------\n    value: int\n        The raw integer color value.\n\n    Operations\n    ----------\n    - ``x == y``:\n        Checks if two colors are equal.\n\n    - ``x != y``:\n        Checks if two colors are not equal.\n\n    - ``str(x)``:\n        Returns the hex format for the colour.\n\n    - ``hash(x)``:\n        Return the color's hash.\n\n    - ``int(x)``:\n        Returns the raw color value.\n    \"\"\"\n\n    def __init__(self, value: int) -&gt; None:\n        self.value = value\n\n    def _get_byte(self, byte: int) -&gt; int:\n        return (self.value &gt;&gt; (8 * byte)) &amp; 0xFF\n\n    def __eq__(self, other: Any) -&gt; bool:\n        return isinstance(other, Color) and self.value == other.value\n\n    def __ne__(self, other: Any) -&gt; bool:\n        return not self.__eq__(other)\n\n    def __str__(self) -&gt; str:\n        return f\"#{self.value:0&gt;6x}\"\n\n    def __int__(self) -&gt; int:\n        return self.value\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;Color value={self.value}&gt;\"\n\n    def __hash__(self) -&gt; int:\n        return hash(self.value)\n\n    @property\n    def r(self) -&gt; int:\n\"\"\"Returns the red component of the color.\"\"\"\n        return self._get_byte(2)\n\n    @property\n    def g(self) -&gt; int:\n\"\"\"Returns the green component of the color.\"\"\"\n        return self._get_byte(1)\n\n    @property\n    def b(self) -&gt; int:\n\"\"\"Returns the blue component of the color.\"\"\"\n        return self._get_byte(0)\n\n    @property\n    def to_rgb(self) -&gt; Tuple[int, int, int]:\n\"\"\"Returns an (r, g, b) tuple representing the color.\"\"\"\n        return self.r, self.g, self.b\n\n    @classmethod\n    def default(cls: Type[CT]) -&gt; CT:\n\"\"\"A factory method that returns a ``Color`` with a value of ``0``.\"\"\"\n        return cls(0)\n\n    @classmethod\n    def from_rgb(cls: Type[CT], r: int, g: int, b: int) -&gt; CT:\n\"\"\"Constructs a ``Color`` from an RGB tuple.\"\"\"\n        return cls((r &lt;&lt; 16) + (g &lt;&lt; 8) + b)\n\n    @classmethod\n    def from_hsv(cls: Type[CT], h: float, s: float, v: float) -&gt; CT:\n\"\"\"Constructs a ``Color`` from an HSV tuple.\"\"\"\n        rgb = colorsys.hsv_to_rgb(h, s, v)\n        return cls.from_rgb(*(int(x * 255) for x in rgb))\n\n    @classmethod\n    def random(\n        cls: Type[CT],\n        *,\n        seed: Optional[Union[int, str, float, bytes, bytearray]] = None,\n    ) -&gt; CT:\n\"\"\"A factory method that returns a ``Color`` with a random hue.\n\n        Parameters\n        ----------\n        seed: Optional[Union[int, str, float, bytes, bytearray]]\n            The seed to initialize the RNG with. If ``None`` is passed the default RNG is used.\n\n        Note\n        ----\n        The random algorithm works by choosing a colour with a random hue but\n        with maxed out saturation and value.\n        \"\"\"\n        return cls.from_hsv(\n            Random(seed).random() if seed is not None else random(), 1, 1\n        )\n\n    @classmethod\n    def from_str(cls, value: str) -&gt; \"Color\":\n\"\"\"Constructs a ``Color`` from a string.\n\n        The following formats are accepted:\n\n        - ``0x&lt;hex&gt;``\n        - ``#&lt;hex&gt;``\n        - ``0x#&lt;hex&gt;``\n        - ``rgb(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;)``\n\n        Like CSS, ``&lt;number&gt;`` can be either 0-255 or 0-100% and ``&lt;hex&gt;`` can be\n        either a 6 digit hex number or a 3 digit hex shortcut (e.g. #FFF).\n\n        Raises\n        -------\n        ValueError\n            The string could not be converted into a color.\n        \"\"\"\n\n        if value[0] == \"#\":\n            return parse_hex_number(value[1:])\n\n        if value[0:2] == \"0x\":\n            rest = value[2:]\n            # Legacy backwards compatible syntax\n            if rest.startswith(\"#\"):\n                return parse_hex_number(rest[1:])\n            return parse_hex_number(rest)\n\n        arg = value.lower()\n        if arg[0:3] == \"rgb\":\n            return parse_rgb(arg)\n\n        raise ValueError(\"unknown colour format given\")\n</code></pre>"},{"location":"api/models/color/#dismake.models.color.Color.b","title":"b  <code>property</code>","text":"<pre><code>b: int\n</code></pre> <p>Returns the blue component of the color.</p>"},{"location":"api/models/color/#dismake.models.color.Color.g","title":"g  <code>property</code>","text":"<pre><code>g: int\n</code></pre> <p>Returns the green component of the color.</p>"},{"location":"api/models/color/#dismake.models.color.Color.r","title":"r  <code>property</code>","text":"<pre><code>r: int\n</code></pre> <p>Returns the red component of the color.</p>"},{"location":"api/models/color/#dismake.models.color.Color.to_rgb","title":"to_rgb  <code>property</code>","text":"<pre><code>to_rgb: Tuple[int, int, int]\n</code></pre> <p>Returns an (r, g, b) tuple representing the color.</p>"},{"location":"api/models/color/#dismake.models.color.Color.default","title":"default  <code>classmethod</code>","text":"<pre><code>default() -&gt; CT\n</code></pre> <p>A factory method that returns a <code>Color</code> with a value of <code>0</code>.</p> Source code in <code>dismake/models/color.py</code> <pre><code>@classmethod\ndef default(cls: Type[CT]) -&gt; CT:\n\"\"\"A factory method that returns a ``Color`` with a value of ``0``.\"\"\"\n    return cls(0)\n</code></pre>"},{"location":"api/models/color/#dismake.models.color.Color.from_hsv","title":"from_hsv  <code>classmethod</code>","text":"<pre><code>from_hsv(h: float, s: float, v: float) -&gt; CT\n</code></pre> <p>Constructs a <code>Color</code> from an HSV tuple.</p> Source code in <code>dismake/models/color.py</code> <pre><code>@classmethod\ndef from_hsv(cls: Type[CT], h: float, s: float, v: float) -&gt; CT:\n\"\"\"Constructs a ``Color`` from an HSV tuple.\"\"\"\n    rgb = colorsys.hsv_to_rgb(h, s, v)\n    return cls.from_rgb(*(int(x * 255) for x in rgb))\n</code></pre>"},{"location":"api/models/color/#dismake.models.color.Color.from_rgb","title":"from_rgb  <code>classmethod</code>","text":"<pre><code>from_rgb(r: int, g: int, b: int) -&gt; CT\n</code></pre> <p>Constructs a <code>Color</code> from an RGB tuple.</p> Source code in <code>dismake/models/color.py</code> <pre><code>@classmethod\ndef from_rgb(cls: Type[CT], r: int, g: int, b: int) -&gt; CT:\n\"\"\"Constructs a ``Color`` from an RGB tuple.\"\"\"\n    return cls((r &lt;&lt; 16) + (g &lt;&lt; 8) + b)\n</code></pre>"},{"location":"api/models/color/#dismake.models.color.Color.from_str","title":"from_str  <code>classmethod</code>","text":"<pre><code>from_str(value: str) -&gt; 'Color'\n</code></pre> <p>Constructs a <code>Color</code> from a string.</p> <p>The following formats are accepted:</p> <ul> <li><code>0x&lt;hex&gt;</code></li> <li><code>#&lt;hex&gt;</code></li> <li><code>0x#&lt;hex&gt;</code></li> <li><code>rgb(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;)</code></li> </ul> <p>Like CSS, <code>&lt;number&gt;</code> can be either 0-255 or 0-100% and <code>&lt;hex&gt;</code> can be either a 6 digit hex number or a 3 digit hex shortcut (e.g. #FFF).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>The string could not be converted into a color.</p> Source code in <code>dismake/models/color.py</code> <pre><code>@classmethod\ndef from_str(cls, value: str) -&gt; \"Color\":\n\"\"\"Constructs a ``Color`` from a string.\n\n    The following formats are accepted:\n\n    - ``0x&lt;hex&gt;``\n    - ``#&lt;hex&gt;``\n    - ``0x#&lt;hex&gt;``\n    - ``rgb(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;)``\n\n    Like CSS, ``&lt;number&gt;`` can be either 0-255 or 0-100% and ``&lt;hex&gt;`` can be\n    either a 6 digit hex number or a 3 digit hex shortcut (e.g. #FFF).\n\n    Raises\n    -------\n    ValueError\n        The string could not be converted into a color.\n    \"\"\"\n\n    if value[0] == \"#\":\n        return parse_hex_number(value[1:])\n\n    if value[0:2] == \"0x\":\n        rest = value[2:]\n        # Legacy backwards compatible syntax\n        if rest.startswith(\"#\"):\n            return parse_hex_number(rest[1:])\n        return parse_hex_number(rest)\n\n    arg = value.lower()\n    if arg[0:3] == \"rgb\":\n        return parse_rgb(arg)\n\n    raise ValueError(\"unknown colour format given\")\n</code></pre>"},{"location":"api/models/color/#dismake.models.color.Color.random","title":"random  <code>classmethod</code>","text":"<pre><code>random(\n    *,\n    seed: Optional[\n        Union[int, str, float, bytes, bytearray]\n    ] = None\n) -&gt; CT\n</code></pre> <p>A factory method that returns a <code>Color</code> with a random hue.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>Optional[Union[int, str, float, bytes, bytearray]]</code> <p>The seed to initialize the RNG with. If <code>None</code> is passed the default RNG is used.</p> <code>None</code>"},{"location":"api/models/color/#dismake.models.color.Color.random--note","title":"Note","text":"<p>The random algorithm works by choosing a colour with a random hue but with maxed out saturation and value.</p> Source code in <code>dismake/models/color.py</code> <pre><code>@classmethod\ndef random(\n    cls: Type[CT],\n    *,\n    seed: Optional[Union[int, str, float, bytes, bytearray]] = None,\n) -&gt; CT:\n\"\"\"A factory method that returns a ``Color`` with a random hue.\n\n    Parameters\n    ----------\n    seed: Optional[Union[int, str, float, bytes, bytearray]]\n        The seed to initialize the RNG with. If ``None`` is passed the default RNG is used.\n\n    Note\n    ----\n    The random algorithm works by choosing a colour with a random hue but\n    with maxed out saturation and value.\n    \"\"\"\n    return cls.from_hsv(\n        Random(seed).random() if seed is not None else random(), 1, 1\n    )\n</code></pre>"},{"location":"api/models/embed/","title":"Embed","text":""},{"location":"api/models/embed/#dismake.models.embed.embed.Embed","title":"Embed","text":"<p>Represents a Discord embed.</p> <p>For your convenience, this class implicitly casts parameters that expect a string to str.</p> <p>Attributes:</p> Name Type Description <code>title</code> <code>str</code> <p>The title of the embed. Can be up to 256 characters.</p> <code>type</code> <code>str</code> <p>The type of embed. Usually \"rich\".</p> <code>description</code> <code>str</code> <p>The description of the embed. Can be up to 4096 characters.</p> <code>url</code> <code>str</code> <p>The URL of the embed.</p> <code>timestamp</code> <code>Optional[datetime]</code> <p>The timestamp of the embed content, an aware datetime. If a naive datetime is passed, it's converted to an aware datetime with the local timezone.</p> <code>color</code> <code>Color</code> <p>The color code of the embed.</p> Source code in <code>dismake/models/embed/embed.py</code> <pre><code>class Embed:\n\"\"\"Represents a Discord embed.\n\n    For your convenience, this class implicitly casts parameters that expect a string to str.\n\n    Attributes\n    -----------\n    title: str\n        The title of the embed. Can be up to 256 characters.\n    type: str\n        The type of embed. Usually \"rich\".\n    description: str\n        The description of the embed. Can be up to 4096 characters.\n    url: str\n        The URL of the embed.\n    timestamp: Optional[datetime]\n        The timestamp of the embed content, an aware datetime.\n        If a naive datetime is passed, it's converted to an aware datetime with the local timezone.\n    color: Color\n        The color code of the embed.\n    \"\"\"\n\n    __slots__: Tuple[str, ...] = (\n        \"title\",\n        \"description\",\n        \"type\",\n        \"url\",\n        \"timestamp\",\n        \"color\",\n        \"_author\",\n        \"_footer\",\n        \"_fields\",\n        \"_image\",\n        \"_thumbnail\",\n        \"_video\",\n        \"_provider\",\n    )\n\n    def __init__(\n        self,\n        *,\n        title: Any = None,\n        description: Any = None,\n        type: EmbedType = \"rich\",\n        url: Any = None,\n        timestamp: Optional[datetime] = None,\n        color: Optional[Color] = None,\n    ) -&gt; None:\n        self.title = title\n        self.description = description\n        self.type = type\n        self.url = url\n        self.color = color\n        self.timestamp: Optional[datetime]\n        if isinstance(timestamp, datetime):\n            if timestamp.tzinfo is None:\n                self.timestamp = timestamp.astimezone()\n        elif timestamp is None:\n            self.timestamp = None\n        else:\n            raise TypeError(\n                f\"Expected datetime.datetime or None received {timestamp.__class__.__name__} instead\"\n            )\n\n    @classmethod\n    def from_dict(cls, data: EmbedData) -&gt; Self:\n\"\"\"Converts a dictionary into an Embed object, provided the data is in the\n        format expected by Discord.\n\n        Parameters\n        -----------\n        data: EmbedData\n            The dictionary containing the data to convert into an Embed.\n\n        Returns\n        --------\n        Embed\n            An Embed object created from the provided dictionary.\n        \"\"\"\n        embed = cls.__new__(cls)\n\n        (embed.title, embed.description, embed.type, embed.url) = (\n            data.get(\"title\"),\n            data.get(\"description\"),\n            data[\"type\"],\n            data.get(\"url\"),\n        )\n\n        try:\n            embed.timestamp = parse_time(data[\"timestamp\"])\n        except KeyError:\n            pass\n\n        try:\n            embed.color = Color(data[\"color\"])\n        except KeyError:\n            pass\n\n        if (author_data := data.get(\"author\")) is not None:\n            setattr(embed, \"_author\", EmbedAuthor.from_dict(author_data))\n\n        if (footer_data := data.get(\"footer\")) is not None:\n            setattr(embed, \"_footer\", EmbedFooter.from_dict(footer_data))\n\n        if (image_data := data.get(\"image\")) is not None:\n            setattr(embed, \"_image\", EmbedAttachment.from_dict(image_data))\n\n        if (thumbnail_data := data.get(\"thumbnail\")) is not None:\n            setattr(embed, \"_thumbnail\", EmbedAttachment.from_dict(thumbnail_data))\n\n        if (video_data := data.get(\"video\")) is not None:\n            setattr(embed, \"_video\", EmbedAttachment.from_dict(video_data))\n\n        if (provider_data := data.get(\"provider\")) is not None:\n            setattr(embed, \"_provider\", EmbedProvider.from_dict(provider_data))\n        if (fields_data := data.get(\"fields\")) is not None:\n            temp_fields: List[EmbedField] = list()\n            for field_data in fields_data:\n                temp_fields.append(EmbedField.from_dict(field_data))\n\n            embed._fields = temp_fields\n        return embed\n\n    def to_dict(self) -&gt; EmbedData:\n\"\"\"Converts this embed object into a dict.\"\"\"\n\n        # Create a base dictionary with the embed type\n        base: EmbedData = {\"type\": self.type}\n\n        # Loop through the slots to extract embed proxies\n        for slot in self.__slots__:\n            # Check if the slot represents an embed proxy (starts with '_')\n            if slot.startswith(\"_\"):\n                # Get the value of the attribute\n                attr_value = getattr(self, slot, None)\n                # Check if the attribute is not None\n                if attr_value is not None:\n                    if slot == \"_fields\":\n                        # Handle the \"_fields\" attribute differently by converting each field to a dictionary\n                        temp_fields: List[EmbedFieldData] = list()\n                        for field in attr_value:\n                            temp_fields.append(field.to_dict())\n                        base[\"fields\"] = temp_fields\n                    else:\n                        # Remove the leading '_' from the slot name and set it as a key in the base dictionary\n                        # Use the \"to_dict()\" method of the attribute to obtain a valid embed proxy dictionary\n                        base[slot[1:]] = attr_value.to_dict()  # type: ignore  # Safe to ignore: Dynamically generated keys from __slots__\n\n        # Check and add optional attributes if they are not None\n        if self.title is not None:\n            base[\"title\"] = self.title\n\n        if self.description is not None:\n            base[\"description\"] = self.description\n\n        if self.color is not None:\n            base[\"color\"] = self.color.value\n\n        if self.timestamp is not None:\n            if self.timestamp.tzinfo:\n                base[\"timestamp\"] = self.timestamp.astimezone(\n                    tz=timezone.utc\n                ).isoformat()\n            else:\n                base[\"timestamp\"] = self.timestamp.replace(\n                    tzinfo=timezone.utc\n                ).isoformat()\n\n        if self.url is not None:\n            base[\"url\"] = self.url\n\n        return base\n\n    def __str__(self) -&gt; str:\n\"\"\"Returns a string representation of the Embed object.\"\"\"\n        return f\"Embed(title='{self.title}', color='{self.color}', fields='{10}')\"\n\n    def copy(self) -&gt; Self:\n\"\"\"Returns a shallow copy of the embed.\"\"\"\n        return self.from_dict(self.to_dict())\n\n    def __len__(self) -&gt; int:\n        attrs = (\n            len(attr)\n            for attr in (\n                self.title,\n                self.description,\n                self.author.name,\n                self.footer.text,\n            )\n            if attr is not None\n        )\n        fields = (\n            (len(field.name) + len(field.value))\n            for field in self.fields\n            if field.name and field.value\n        )\n        return sum(attrs) + sum(fields)\n\n    @property\n    def author(self) -&gt; EmbedAuthor:\n\"\"\"Returns an ``EmbedAuthor`` representing the author of the embed.\n\n        If the attribute has no value, an empty ``EmbedAuthor`` will be returned.\n        \"\"\"\n        return getattr(self, \"_author\", EmbedAuthor())\n\n    def set_author(\n        self,\n        name: Optional[str] = None,\n        *,\n        url: Optional[str] = None,\n        icon_url: Optional[str] = None,\n    ) -&gt; Self:\n\"\"\"Sets the author for the embed content.\n\n        This method returns the class instance to allow for fluent-style chaining.\n\n        Parameters\n        -----------\n        name: Optional[str]\n            The name of the author. Can be up to 256 characters.\n        url: Optional[str]\n            The URL for the author.\n        icon_url: Optional[str]\n            The URL of the author's icon. Only HTTP(S) URLs are supported.\n            Inline attachment URLs are also supported.\n\n        Note\n        ----\n        If all parameters are set to ``None``, the author information in the embed\n        will be cleared.\n        \"\"\"\n        if name is None:\n            self._author = None\n        else:\n            self._author = EmbedAuthor(name=name, url=url, icon_url=icon_url)\n        return self\n\n    @property\n    def footer(self) -&gt; EmbedFooter:\n\"\"\"Returns an ``EmbedFooter`` denoting the footer contents.\n\n        If the attribute has no value, an empty ``EmbedFooter`` will be returned.\n        \"\"\"\n        return getattr(self, \"_footer\", EmbedFooter())\n\n    def set_footer(\n        self,\n        text: Optional[str] = None,\n        *,\n        icon_url: Optional[str] = None,\n    ) -&gt; Self:\n\"\"\"Sets the footer for the embed content.\n\n        This method returns the class instance to allow for fluent-style chaining.\n\n        Parameters\n        -----------\n        text: str\n            The footer text. Can only be up to 2048 characters.\n        icon_url: str\n            The URL of the footer icon. Only HTTP(S) is supported.\n            Inline attachment URLs are also supported.\n\n        Note\n        ----\n        If all parameters are set to ``None``, the footer information in the embed\n        will be cleared.\n        \"\"\"\n        if text is None:\n            self._footer = None\n\n        else:\n            self._footer = EmbedFooter(text=text, icon_url=icon_url)\n        return self\n\n    @property\n    def fields(self) -&gt; List[EmbedField]:\n\"\"\"List[``EmbedField``]: Returns a `list` of ``EmbedProxy`` denoting the field contents.\n\n        If the attribute has no value, an empty list will be returned.\n        \"\"\"\n        return getattr(self, \"_fields\", [])\n\n    def add_field(self, name: str, value: str, inline: Optional[bool] = None) -&gt; Self:\n\"\"\"Adds a field to the embed object.\n\n        This function returns the class instance to allow for fluent-style\n        chaining. Can only be up to 25 fields.\n\n        Parameters\n        -----------\n        name: str\n            The name of the field. Can only be up to 256 characters.\n        value: str\n            The value of the field. Can only be up to 1024 characters.\n        inline: Optional[bool]\n            Whether the field should be displayed inline.\n        \"\"\"\n        if not getattr(self, \"_fields\", None):\n            self._fields: List[EmbedField] = []\n\n        self.fields.append(EmbedField(name=name, value=value, inline=inline))\n        return self\n\n    @property\n    def image(self) -&gt; EmbedAttachment:\n\"\"\"Returns an ``EmbedAttachment`` representing the image of the embed.\n\n        If the attribute has no value, an empty ``EmbedAttachment`` will be returned.\n        \"\"\"\n        return getattr(self, \"_image\", EmbedAttachment())\n\n    def set_image(\n        self,\n        url: Optional[str] = None,\n    ) -&gt; Self:\n\"\"\"Sets the image for the embed content.\n\n        This method returns the class instance to allow for fluent-style chaining.\n\n        Parameters\n        -----------\n        url: Optional[str]\n            The URL of the image.\n\n        Note\n        ----\n        If all parameters are set to ``None``, the image information in the embed\n        will be cleared.\n        \"\"\"\n        if url is None:\n            self._image = None\n\n        self._image = EmbedAttachment(url=url)\n        return self\n\n    @property\n    def thumbnail(self) -&gt; EmbedAttachment:\n\"\"\"Returns an ``EmbedAttachment`` representing the thumbnail image of the embed.\n\n        If the attribute has no value, an empty ``EmbedAttachment`` will be returned.\n        \"\"\"\n        return getattr(self, \"_thumbnail\", EmbedAttachment())\n\n    def set_thumbnail(self, url: Optional[str] = None) -&gt; Self:\n\"\"\"Sets the thumbnail image for the embed content.\n\n        This method returns the class instance to allow for fluent-style chaining.\n\n        Parameters\n        -----------\n        url: Optional[str]\n            The URL of the thumbnail image.\n\n        Note\n        ----\n        If all parameters are set to ``None``, the thumbnail image information in the embed\n        will be cleared.\n        \"\"\"\n        if url is None:\n            self._thumbnail = None\n\n        self._thumbnail = EmbedAttachment(url=url)\n        return self\n\n    @property\n    def video(self) -&gt; EmbedAttachment:\n\"\"\"Returns an ``EmbedVideo`` representing the video attachment of the embed.\n\n        If the attribute has no value, an empty ``EmbedVideo`` will be returned.\n        \"\"\"\n        return getattr(self, \"_video\", EmbedAttachment())\n\n    @property\n    def provider(self) -&gt; EmbedProvider:\n\"\"\"Returns an ``EmbedProvider`` representing the provider of the embed.\n\n        If the attribute has no value, an empty ``EmbedProvider`` will be returned.\n        \"\"\"\n        return getattr(self, \"_provider\", EmbedProvider())\n</code></pre>"},{"location":"api/models/embed/#dismake.models.embed.embed.Embed.author","title":"author  <code>property</code>","text":"<pre><code>author: EmbedAuthor\n</code></pre> <p>Returns an <code>EmbedAuthor</code> representing the author of the embed.</p> <p>If the attribute has no value, an empty <code>EmbedAuthor</code> will be returned.</p>"},{"location":"api/models/embed/#dismake.models.embed.embed.Embed.fields","title":"fields  <code>property</code>","text":"<pre><code>fields: List[EmbedField]\n</code></pre> <p>List[<code>EmbedField</code>]: Returns a <code>list</code> of <code>EmbedProxy</code> denoting the field contents.</p> <p>If the attribute has no value, an empty list will be returned.</p>"},{"location":"api/models/embed/#dismake.models.embed.embed.Embed.footer","title":"footer  <code>property</code>","text":"<pre><code>footer: EmbedFooter\n</code></pre> <p>Returns an <code>EmbedFooter</code> denoting the footer contents.</p> <p>If the attribute has no value, an empty <code>EmbedFooter</code> will be returned.</p>"},{"location":"api/models/embed/#dismake.models.embed.embed.Embed.image","title":"image  <code>property</code>","text":"<pre><code>image: EmbedAttachment\n</code></pre> <p>Returns an <code>EmbedAttachment</code> representing the image of the embed.</p> <p>If the attribute has no value, an empty <code>EmbedAttachment</code> will be returned.</p>"},{"location":"api/models/embed/#dismake.models.embed.embed.Embed.provider","title":"provider  <code>property</code>","text":"<pre><code>provider: EmbedProvider\n</code></pre> <p>Returns an <code>EmbedProvider</code> representing the provider of the embed.</p> <p>If the attribute has no value, an empty <code>EmbedProvider</code> will be returned.</p>"},{"location":"api/models/embed/#dismake.models.embed.embed.Embed.thumbnail","title":"thumbnail  <code>property</code>","text":"<pre><code>thumbnail: EmbedAttachment\n</code></pre> <p>Returns an <code>EmbedAttachment</code> representing the thumbnail image of the embed.</p> <p>If the attribute has no value, an empty <code>EmbedAttachment</code> will be returned.</p>"},{"location":"api/models/embed/#dismake.models.embed.embed.Embed.video","title":"video  <code>property</code>","text":"<pre><code>video: EmbedAttachment\n</code></pre> <p>Returns an <code>EmbedVideo</code> representing the video attachment of the embed.</p> <p>If the attribute has no value, an empty <code>EmbedVideo</code> will be returned.</p>"},{"location":"api/models/embed/#dismake.models.embed.embed.Embed.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Returns a string representation of the Embed object.</p> Source code in <code>dismake/models/embed/embed.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns a string representation of the Embed object.\"\"\"\n    return f\"Embed(title='{self.title}', color='{self.color}', fields='{10}')\"\n</code></pre>"},{"location":"api/models/embed/#dismake.models.embed.embed.Embed.add_field","title":"add_field","text":"<pre><code>add_field(\n    name: str, value: str, inline: Optional[bool] = None\n) -&gt; Self\n</code></pre> <p>Adds a field to the embed object.</p> <p>This function returns the class instance to allow for fluent-style chaining. Can only be up to 25 fields.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the field. Can only be up to 256 characters.</p> required <code>value</code> <code>str</code> <p>The value of the field. Can only be up to 1024 characters.</p> required <code>inline</code> <code>Optional[bool]</code> <p>Whether the field should be displayed inline.</p> <code>None</code> Source code in <code>dismake/models/embed/embed.py</code> <pre><code>def add_field(self, name: str, value: str, inline: Optional[bool] = None) -&gt; Self:\n\"\"\"Adds a field to the embed object.\n\n    This function returns the class instance to allow for fluent-style\n    chaining. Can only be up to 25 fields.\n\n    Parameters\n    -----------\n    name: str\n        The name of the field. Can only be up to 256 characters.\n    value: str\n        The value of the field. Can only be up to 1024 characters.\n    inline: Optional[bool]\n        Whether the field should be displayed inline.\n    \"\"\"\n    if not getattr(self, \"_fields\", None):\n        self._fields: List[EmbedField] = []\n\n    self.fields.append(EmbedField(name=name, value=value, inline=inline))\n    return self\n</code></pre>"},{"location":"api/models/embed/#dismake.models.embed.embed.Embed.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Returns a shallow copy of the embed.</p> Source code in <code>dismake/models/embed/embed.py</code> <pre><code>def copy(self) -&gt; Self:\n\"\"\"Returns a shallow copy of the embed.\"\"\"\n    return self.from_dict(self.to_dict())\n</code></pre>"},{"location":"api/models/embed/#dismake.models.embed.embed.Embed.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: EmbedData) -&gt; Self\n</code></pre> <p>Converts a dictionary into an Embed object, provided the data is in the format expected by Discord.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>EmbedData</code> <p>The dictionary containing the data to convert into an Embed.</p> required <p>Returns:</p> Type Description <code>Embed</code> <p>An Embed object created from the provided dictionary.</p> Source code in <code>dismake/models/embed/embed.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: EmbedData) -&gt; Self:\n\"\"\"Converts a dictionary into an Embed object, provided the data is in the\n    format expected by Discord.\n\n    Parameters\n    -----------\n    data: EmbedData\n        The dictionary containing the data to convert into an Embed.\n\n    Returns\n    --------\n    Embed\n        An Embed object created from the provided dictionary.\n    \"\"\"\n    embed = cls.__new__(cls)\n\n    (embed.title, embed.description, embed.type, embed.url) = (\n        data.get(\"title\"),\n        data.get(\"description\"),\n        data[\"type\"],\n        data.get(\"url\"),\n    )\n\n    try:\n        embed.timestamp = parse_time(data[\"timestamp\"])\n    except KeyError:\n        pass\n\n    try:\n        embed.color = Color(data[\"color\"])\n    except KeyError:\n        pass\n\n    if (author_data := data.get(\"author\")) is not None:\n        setattr(embed, \"_author\", EmbedAuthor.from_dict(author_data))\n\n    if (footer_data := data.get(\"footer\")) is not None:\n        setattr(embed, \"_footer\", EmbedFooter.from_dict(footer_data))\n\n    if (image_data := data.get(\"image\")) is not None:\n        setattr(embed, \"_image\", EmbedAttachment.from_dict(image_data))\n\n    if (thumbnail_data := data.get(\"thumbnail\")) is not None:\n        setattr(embed, \"_thumbnail\", EmbedAttachment.from_dict(thumbnail_data))\n\n    if (video_data := data.get(\"video\")) is not None:\n        setattr(embed, \"_video\", EmbedAttachment.from_dict(video_data))\n\n    if (provider_data := data.get(\"provider\")) is not None:\n        setattr(embed, \"_provider\", EmbedProvider.from_dict(provider_data))\n    if (fields_data := data.get(\"fields\")) is not None:\n        temp_fields: List[EmbedField] = list()\n        for field_data in fields_data:\n            temp_fields.append(EmbedField.from_dict(field_data))\n\n        embed._fields = temp_fields\n    return embed\n</code></pre>"},{"location":"api/models/embed/#dismake.models.embed.embed.Embed.set_author","title":"set_author","text":"<pre><code>set_author(\n    name: Optional[str] = None,\n    *,\n    url: Optional[str] = None,\n    icon_url: Optional[str] = None\n) -&gt; Self\n</code></pre> <p>Sets the author for the embed content.</p> <p>This method returns the class instance to allow for fluent-style chaining.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the author. Can be up to 256 characters.</p> <code>None</code> <code>url</code> <code>Optional[str]</code> <p>The URL for the author.</p> <code>None</code> <code>icon_url</code> <code>Optional[str]</code> <p>The URL of the author's icon. Only HTTP(S) URLs are supported. Inline attachment URLs are also supported.</p> <code>None</code>"},{"location":"api/models/embed/#dismake.models.embed.embed.Embed.set_author--note","title":"Note","text":"<p>If all parameters are set to <code>None</code>, the author information in the embed will be cleared.</p> Source code in <code>dismake/models/embed/embed.py</code> <pre><code>def set_author(\n    self,\n    name: Optional[str] = None,\n    *,\n    url: Optional[str] = None,\n    icon_url: Optional[str] = None,\n) -&gt; Self:\n\"\"\"Sets the author for the embed content.\n\n    This method returns the class instance to allow for fluent-style chaining.\n\n    Parameters\n    -----------\n    name: Optional[str]\n        The name of the author. Can be up to 256 characters.\n    url: Optional[str]\n        The URL for the author.\n    icon_url: Optional[str]\n        The URL of the author's icon. Only HTTP(S) URLs are supported.\n        Inline attachment URLs are also supported.\n\n    Note\n    ----\n    If all parameters are set to ``None``, the author information in the embed\n    will be cleared.\n    \"\"\"\n    if name is None:\n        self._author = None\n    else:\n        self._author = EmbedAuthor(name=name, url=url, icon_url=icon_url)\n    return self\n</code></pre>"},{"location":"api/models/embed/#dismake.models.embed.embed.Embed.set_footer","title":"set_footer","text":"<pre><code>set_footer(\n    text: Optional[str] = None,\n    *,\n    icon_url: Optional[str] = None\n) -&gt; Self\n</code></pre> <p>Sets the footer for the embed content.</p> <p>This method returns the class instance to allow for fluent-style chaining.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>Optional[str]</code> <p>The footer text. Can only be up to 2048 characters.</p> <code>None</code> <code>icon_url</code> <code>Optional[str]</code> <p>The URL of the footer icon. Only HTTP(S) is supported. Inline attachment URLs are also supported.</p> <code>None</code>"},{"location":"api/models/embed/#dismake.models.embed.embed.Embed.set_footer--note","title":"Note","text":"<p>If all parameters are set to <code>None</code>, the footer information in the embed will be cleared.</p> Source code in <code>dismake/models/embed/embed.py</code> <pre><code>def set_footer(\n    self,\n    text: Optional[str] = None,\n    *,\n    icon_url: Optional[str] = None,\n) -&gt; Self:\n\"\"\"Sets the footer for the embed content.\n\n    This method returns the class instance to allow for fluent-style chaining.\n\n    Parameters\n    -----------\n    text: str\n        The footer text. Can only be up to 2048 characters.\n    icon_url: str\n        The URL of the footer icon. Only HTTP(S) is supported.\n        Inline attachment URLs are also supported.\n\n    Note\n    ----\n    If all parameters are set to ``None``, the footer information in the embed\n    will be cleared.\n    \"\"\"\n    if text is None:\n        self._footer = None\n\n    else:\n        self._footer = EmbedFooter(text=text, icon_url=icon_url)\n    return self\n</code></pre>"},{"location":"api/models/embed/#dismake.models.embed.embed.Embed.set_image","title":"set_image","text":"<pre><code>set_image(url: Optional[str] = None) -&gt; Self\n</code></pre> <p>Sets the image for the embed content.</p> <p>This method returns the class instance to allow for fluent-style chaining.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Optional[str]</code> <p>The URL of the image.</p> <code>None</code>"},{"location":"api/models/embed/#dismake.models.embed.embed.Embed.set_image--note","title":"Note","text":"<p>If all parameters are set to <code>None</code>, the image information in the embed will be cleared.</p> Source code in <code>dismake/models/embed/embed.py</code> <pre><code>def set_image(\n    self,\n    url: Optional[str] = None,\n) -&gt; Self:\n\"\"\"Sets the image for the embed content.\n\n    This method returns the class instance to allow for fluent-style chaining.\n\n    Parameters\n    -----------\n    url: Optional[str]\n        The URL of the image.\n\n    Note\n    ----\n    If all parameters are set to ``None``, the image information in the embed\n    will be cleared.\n    \"\"\"\n    if url is None:\n        self._image = None\n\n    self._image = EmbedAttachment(url=url)\n    return self\n</code></pre>"},{"location":"api/models/embed/#dismake.models.embed.embed.Embed.set_thumbnail","title":"set_thumbnail","text":"<pre><code>set_thumbnail(url: Optional[str] = None) -&gt; Self\n</code></pre> <p>Sets the thumbnail image for the embed content.</p> <p>This method returns the class instance to allow for fluent-style chaining.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Optional[str]</code> <p>The URL of the thumbnail image.</p> <code>None</code>"},{"location":"api/models/embed/#dismake.models.embed.embed.Embed.set_thumbnail--note","title":"Note","text":"<p>If all parameters are set to <code>None</code>, the thumbnail image information in the embed will be cleared.</p> Source code in <code>dismake/models/embed/embed.py</code> <pre><code>def set_thumbnail(self, url: Optional[str] = None) -&gt; Self:\n\"\"\"Sets the thumbnail image for the embed content.\n\n    This method returns the class instance to allow for fluent-style chaining.\n\n    Parameters\n    -----------\n    url: Optional[str]\n        The URL of the thumbnail image.\n\n    Note\n    ----\n    If all parameters are set to ``None``, the thumbnail image information in the embed\n    will be cleared.\n    \"\"\"\n    if url is None:\n        self._thumbnail = None\n\n    self._thumbnail = EmbedAttachment(url=url)\n    return self\n</code></pre>"},{"location":"api/models/embed/#dismake.models.embed.embed.Embed.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; EmbedData\n</code></pre> <p>Converts this embed object into a dict.</p> Source code in <code>dismake/models/embed/embed.py</code> <pre><code>def to_dict(self) -&gt; EmbedData:\n\"\"\"Converts this embed object into a dict.\"\"\"\n\n    # Create a base dictionary with the embed type\n    base: EmbedData = {\"type\": self.type}\n\n    # Loop through the slots to extract embed proxies\n    for slot in self.__slots__:\n        # Check if the slot represents an embed proxy (starts with '_')\n        if slot.startswith(\"_\"):\n            # Get the value of the attribute\n            attr_value = getattr(self, slot, None)\n            # Check if the attribute is not None\n            if attr_value is not None:\n                if slot == \"_fields\":\n                    # Handle the \"_fields\" attribute differently by converting each field to a dictionary\n                    temp_fields: List[EmbedFieldData] = list()\n                    for field in attr_value:\n                        temp_fields.append(field.to_dict())\n                    base[\"fields\"] = temp_fields\n                else:\n                    # Remove the leading '_' from the slot name and set it as a key in the base dictionary\n                    # Use the \"to_dict()\" method of the attribute to obtain a valid embed proxy dictionary\n                    base[slot[1:]] = attr_value.to_dict()  # type: ignore  # Safe to ignore: Dynamically generated keys from __slots__\n\n    # Check and add optional attributes if they are not None\n    if self.title is not None:\n        base[\"title\"] = self.title\n\n    if self.description is not None:\n        base[\"description\"] = self.description\n\n    if self.color is not None:\n        base[\"color\"] = self.color.value\n\n    if self.timestamp is not None:\n        if self.timestamp.tzinfo:\n            base[\"timestamp\"] = self.timestamp.astimezone(\n                tz=timezone.utc\n            ).isoformat()\n        else:\n            base[\"timestamp\"] = self.timestamp.replace(\n                tzinfo=timezone.utc\n            ).isoformat()\n\n    if self.url is not None:\n        base[\"url\"] = self.url\n\n    return base\n</code></pre>"},{"location":"api/models/interaction/","title":"Interaction","text":""},{"location":"api/models/interaction/#dismake.models.interaction.Interaction","title":"Interaction","text":"<p>             Bases: <code>Generic[ClientT]</code></p> <p>Represents a Discord interaction.</p> <p>An interaction happens when a user does an action that needs to be notified. Current examples are slash commands and components.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The interaction's ID.</p> <code>type</code> <code>InteractionType</code> <p>The interaction type.</p> <code>guild_id</code> <code>Optional[int]</code> <p>The guild ID the interaction was sent from.</p> <code>channel</code> <code>Optional[Any]</code> <p>The channel the interaction was sent from.</p> <code>application_id</code> <code>int</code> <p>The application ID that the interaction was for.</p> <code>user</code> <code>Union[User, Member]</code> <p>The user or member that sent the interaction.</p> <code>message</code> <code>Optional[Message]</code> <p>The message that sent this interaction. This is only available for :attr:<code>InteractionType.component</code> interactions.</p> <code>token</code> <code>str</code> <p>The token to continue the interaction. These are valid for 15 minutes.</p> <code>data</code> <code>dict</code> <p>The raw interaction data.</p> <code>locale</code> <code>Locale</code> <p>The locale of the user invoking the interaction.</p> <code>guild_locale</code> <code>Optional[Locale]</code> <p>The preferred locale of the guild the interaction was sent from, if any.</p> Source code in <code>dismake/models/interaction.py</code> <pre><code>class Interaction(Generic[ClientT]):\n\"\"\"Represents a Discord interaction.\n\n    An interaction happens when a user does an action that needs to\n    be notified. Current examples are slash commands and components.\n\n    Attributes\n    -----------\n    id: int\n        The interaction's ID.\n    type: InteractionType\n        The interaction type.\n    guild_id: Optional[int]\n        The guild ID the interaction was sent from.\n    channel: Optional[Any]\n        The channel the interaction was sent from.\n    application_id: int\n        The application ID that the interaction was for.\n    user: Union[User, Member]\n        The user or member that sent the interaction.\n    message: Optional[Message]\n        The message that sent this interaction.\n        This is only available for :attr:`InteractionType.component` interactions.\n    token: str\n        The token to continue the interaction. These are valid\n        for 15 minutes.\n    data: dict\n        The raw interaction data.\n    locale: Locale\n        The locale of the user invoking the interaction.\n    guild_locale: Optional[Locale]\n        The preferred locale of the guild the interaction was sent from, if any.\n    \"\"\"\n\n    __slots__: Tuple[str, ...] = (\n        \"_client\",\n        \"data\",\n        \"id\",\n        \"type\",\n        \"application_id\",\n        \"guild_id\",\n        \"channel\",\n        \"channel_id\",\n        \"token\",\n        \"version\",\n        \"app_permissions\",\n        \"locale\",\n        \"guild_locale\",\n        \"message\",\n        \"user\",\n        \"_responded\",\n    )\n\n    def __init__(self, client: ClientT, data: InteractionData) -&gt; None:\n        self._client = client\n        self.data = data\n        self.id: int = int(data[\"id\"])\n        self.type: InteractionType = InteractionType(int(data[\"type\"]))\n        self.application_id: Snowflake = data[\"application_id\"]\n        self.guild_id: Optional[int] = get_as_snowflake(data, \"guild_id\")\n        self.channel: Optional[Any] = get_as_snowflake(data, \"channel\")\n        self.channel_id: Optional[int] = get_as_snowflake(data, \"channel_id\")\n        self.token: str = data[\"token\"]\n        self.version: int = data[\"version\"]\n        self.app_permissions: Optional[str] = data.get(\"app_permissions\")\n        self.locale: Optional[str] = data.get(\"locale\")\n        self.guild_locale: Optional[str] = data.get(\"guild_locale\")\n\n        self.message: Optional[Message] = (\n            Message(client=client, data=data[\"message\"]) if \"message\" in data else None\n        )\n\n        self.user: Optional[Union[User, Member]] = (\n            Member(client=client, guild_id=self.guild_id, data=data[\"member\"])\n            if self.guild_id is not None and \"member\" in data\n            else User(client=client, data=data[\"user\"])\n            if \"user\" in data\n            else None\n        )\n\n        self._responded: bool = False\n\n    @property\n    def is_ping(self) -&gt; bool:\n\"\"\"Indicates whether this interaction is a Ping Interaction.\"\"\"\n        return self.type == InteractionType.PING\n\n    @property\n    def is_application_command(self) -&gt; bool:\n\"\"\"Indicates whether this interaction is an Application Command Interaction.\"\"\"\n        return self.type == InteractionType.APPLICATION_COMMAND\n\n    @property\n    def is_message_component(self) -&gt; bool:\n\"\"\"Indicates whether this interaction is a Message Component Interaction.\"\"\"\n        return self.type == InteractionType.MESSAGE_COMPONENT\n\n    @property\n    def is_autocomplete(self) -&gt; bool:\n\"\"\"Indicates whether this interaction is a Application Command Autocomplete Interaction.\"\"\"\n        return self.type == InteractionType.APPLICATION_COMMAND_AUTOCOMPLETE\n\n    @property\n    def is_modal_submit(self) -&gt; bool:\n\"\"\"Indicates whether this interaction is a Modal submit Interaction.\"\"\"\n        return self.type == InteractionType.MODAL_SUBMIT\n\n    @property\n    def is_responded(self) -&gt; bool:\n\"\"\"Indicates whether this interaction is responded.\"\"\"\n        return self._responded\n</code></pre>"},{"location":"api/models/interaction/#dismake.models.interaction.Interaction.is_application_command","title":"is_application_command  <code>property</code>","text":"<pre><code>is_application_command: bool\n</code></pre> <p>Indicates whether this interaction is an Application Command Interaction.</p>"},{"location":"api/models/interaction/#dismake.models.interaction.Interaction.is_autocomplete","title":"is_autocomplete  <code>property</code>","text":"<pre><code>is_autocomplete: bool\n</code></pre> <p>Indicates whether this interaction is a Application Command Autocomplete Interaction.</p>"},{"location":"api/models/interaction/#dismake.models.interaction.Interaction.is_message_component","title":"is_message_component  <code>property</code>","text":"<pre><code>is_message_component: bool\n</code></pre> <p>Indicates whether this interaction is a Message Component Interaction.</p>"},{"location":"api/models/interaction/#dismake.models.interaction.Interaction.is_modal_submit","title":"is_modal_submit  <code>property</code>","text":"<pre><code>is_modal_submit: bool\n</code></pre> <p>Indicates whether this interaction is a Modal submit Interaction.</p>"},{"location":"api/models/interaction/#dismake.models.interaction.Interaction.is_ping","title":"is_ping  <code>property</code>","text":"<pre><code>is_ping: bool\n</code></pre> <p>Indicates whether this interaction is a Ping Interaction.</p>"},{"location":"api/models/interaction/#dismake.models.interaction.Interaction.is_responded","title":"is_responded  <code>property</code>","text":"<pre><code>is_responded: bool\n</code></pre> <p>Indicates whether this interaction is responded.</p>"},{"location":"api/models/member/","title":"Member","text":""},{"location":"api/models/member/#dismake.models.member.Member","title":"Member","text":"<p>             Bases: <code>User</code></p> <p>Represents a guild member within a Discord server.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>The client application that manages this member.</p> required <code>data</code> <code>MemberData</code> <p>The data payload containing member information.</p> required <p>Attributes:</p> Name Type Description <code>username</code> <code>str</code> <p>The username of the member.</p> <code>id</code> <code>int</code> <p>The unique ID of the member.</p> <code>discriminator</code> <code>str</code> <p>The discriminator of the member. (Legacy concept)</p> <code>global_name</code> <code>Optional[str]</code> <p>The member's global nickname, taking precedence over the username in display.</p> <code>bot</code> <code>bool</code> <p>Indicates whether the member is a bot account.</p> <code>system</code> <code>bool</code> <p>Indicates whether the member represents Discord officially (system user).</p> <code>mfa_enabled</code> <code>bool</code> <p>Indicates whether two-factor authentication is enabled for the member.</p> <code>accent_color</code> <code>Optional[Color]</code> <p>The member's accent color if present; otherwise, None.</p> <code>locale</code> <code>str</code> <p>The member's locale.</p> <code>verified</code> <code>bool</code> <p>Indicates whether the member is verified.</p> <code>email</code> <code>Optional[str]</code> <p>The member's email address, if available.</p> <code>flags</code> <code>int</code> <p>Flags associated with the member.</p> <code>premium_type</code> <code>int</code> <p>The member's premium type.</p> <code>public_flags</code> <code>int</code> <p>Public flags associated with the member.</p> <code>avatar_decoration</code> <code>str</code> <p>The hash of the member's avatar decoration.</p> <code>nickname</code> <code>Optional[str]</code> <p>The nickname of the member within the guild.</p> <code>roles</code> <code>List[Snowflake]</code> <p>List of role IDs that the member has.</p> <code>joined_at</code> <code>datetime</code> <p>The date and time when the member joined the guild.</p> <code>premium_since</code> <code>Optional[datetime]</code> <p>The date and time when the member became a premium subscriber.</p> <code>deaf</code> <code>bool</code> <p>Indicates whether the member is deafened in voice channels.</p> <code>mute</code> <code>bool</code> <p>Indicates whether the member is muted in voice channels.</p> <code>pending</code> <code>bool</code> <p>Indicates whether the member has a pending invitation to the guild.</p> <code>permissions</code> <code>Permissions</code> <p>The member's permissions within the guild.</p> <code>communication_disabled_until</code> <code>datetime</code> <p>The date and time until which the member's communication is disabled.</p> <code>flags</code> <code>MemberFlags</code> <p>Flags representing various member states.</p>"},{"location":"api/models/member/#dismake.models.member.Member--operations","title":"Operations","text":"<ul> <li> <p><code>x == y</code>:     Checks if two users are equal.</p> </li> <li> <p><code>x != y</code>:     Checks if two users are not equal.</p> </li> <li> <p><code>str(x)</code>:     Returns the username.</p> </li> </ul> Source code in <code>dismake/models/member.py</code> <pre><code>class Member(User):\n\"\"\"Represents a guild member within a Discord server.\n\n    Parameters\n    ----------\n    client: Client\n        The client application that manages this member.\n    data: MemberData\n        The data payload containing member information.\n\n    Attributes\n    ----------\n    username: str\n        The username of the member.\n    id: int\n        The unique ID of the member.\n    discriminator: str\n        The discriminator of the member. (Legacy concept)\n    global_name: Optional[str]\n        The member's global nickname, taking precedence over the username in display.\n    bot: bool\n        Indicates whether the member is a bot account.\n    system: bool\n        Indicates whether the member represents Discord officially (system user).\n    mfa_enabled: bool\n        Indicates whether two-factor authentication is enabled for the member.\n    accent_color: Optional[Color]\n        The member's accent color if present; otherwise, None.\n    locale: str\n        The member's locale.\n    verified: bool\n        Indicates whether the member is verified.\n    email: Optional[str]\n        The member's email address, if available.\n    flags: int\n        Flags associated with the member.\n    premium_type: int\n        The member's premium type.\n    public_flags: int\n        Public flags associated with the member.\n    avatar_decoration: str\n        The hash of the member's avatar decoration.\n    nickname: Optional[str]\n        The nickname of the member within the guild.\n    roles: List[Snowflake]\n        List of role IDs that the member has.\n    joined_at: datetime\n        The date and time when the member joined the guild.\n    premium_since: Optional[datetime]\n        The date and time when the member became a premium subscriber.\n    deaf: bool\n        Indicates whether the member is deafened in voice channels.\n    mute: bool\n        Indicates whether the member is muted in voice channels.\n    pending: bool\n        Indicates whether the member has a pending invitation to the guild.\n    permissions: Permissions\n        The member's permissions within the guild.\n    communication_disabled_until: datetime\n        The date and time until which the member's communication is disabled.\n    flags: MemberFlags\n        Flags representing various member states.\n\n    Operations\n    ----------\n    - ``x == y``:\n        Checks if two users are equal.\n\n    - ``x != y``:\n        Checks if two users are not equal.\n\n    - ``str(x)``:\n        Returns the username.\n\n    \"\"\"\n\n    __slots__: Tuple[str, ...] = (\n        \"nickname\",\n        \"_avatar\",\n        \"roles\",\n        \"joined_at\",\n        \"premium_since\",\n        \"deaf\",\n        \"mute\",\n        \"pending\",\n        \"permissions\",\n        \"communication_disabled_until\",\n        \"flags\",\n    )\n\n    def __init__(self, client: Client, guild_id: int, data: MemberData) -&gt; None:\n        super().__init__(client=client, data=data[\"user\"])\n        self.guild = PartialGuild(client=client, id=guild_id)\n        self.nickname: Optional[str] = data.get(\"nick\")\n        self._avatar: Optional[str] = data.get(\"avatar\")\n        self.roles: List[Snowflake] = data.get(\"roles\") or []\n        self.joined_at: str = data[\"joined_at\"]\n        self.premium_since: Optional[datetime] = parse_time(data.get(\"premium_since\"))\n        self.deaf: bool = data[\"deaf\"]\n        self.mute: bool = data[\"mute\"]\n        self.pending: bool = data.get(\"pending\", False)\n        self.permissions: Permissions = Permissions.from_value(data.get(\"permissions\"))\n        self.communication_disabled_until: Optional[datetime] = parse_time(\n            data.get(\"communication_disabled_until\")\n        )\n        self.flags: MemberFlags = MemberFlags(int(data.get(\"flags\", 0)))\n\n    @property\n    def guild_avatar(self) -&gt; Optional[Asset]:\n\"\"\"Returns an ``Asset`` for the guild avatar the member has.\"\"\"\n        if self._avatar is None:\n            return None\n        return Asset.from_guild_avatar(self.guild.id, self.id, self._avatar)\n\n    @property\n    def display_avatar(self) -&gt; Asset:\n\"\"\"Returns the member's display avatar.\n\n        For regular members this is just their avatar, but\n        if they have a guild specific avatar then that\n        is returned instead.\n        \"\"\"\n        return self.guild_avatar or self.avatar or self.default_avatar\n</code></pre>"},{"location":"api/models/member/#dismake.models.member.Member.display_avatar","title":"display_avatar  <code>property</code>","text":"<pre><code>display_avatar: Asset\n</code></pre> <p>Returns the member's display avatar.</p> <p>For regular members this is just their avatar, but if they have a guild specific avatar then that is returned instead.</p>"},{"location":"api/models/member/#dismake.models.member.Member.guild_avatar","title":"guild_avatar  <code>property</code>","text":"<pre><code>guild_avatar: Optional[Asset]\n</code></pre> <p>Returns an <code>Asset</code> for the guild avatar the member has.</p>"},{"location":"api/models/member/#dismake.models.member.MemberFlags","title":"MemberFlags","text":"<p>             Bases: <code>IntEnum</code></p> <p>The known guild member flags that represent various member states.</p> Source code in <code>dismake/models/member.py</code> <pre><code>class MemberFlags(IntEnum):\n\"\"\"The known guild member flags that represent various member states.\"\"\"\n\n    DID_REJOIN = 1 &lt;&lt; 0\n\"\"\"Member has left and rejoined the guild (false)\"\"\"\n    COMPLETED_ONBOARDING = 1 &lt;&lt; 1\n\"\"\"Member has completed onboarding (false)\"\"\"\n    BYPASSES_VERIFICATION = 1 &lt;&lt; 2\n\"\"\"Member is exempt from guild verification requirements (true)\"\"\"\n    STARTED_ONBOARDING = 1 &lt;&lt; 3\n\"\"\"Member has started onboarding (false)\"\"\"\n</code></pre>"},{"location":"api/models/member/#dismake.models.member.MemberFlags.BYPASSES_VERIFICATION","title":"BYPASSES_VERIFICATION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BYPASSES_VERIFICATION = 1 &lt;&lt; 2\n</code></pre> <p>Member is exempt from guild verification requirements (true)</p>"},{"location":"api/models/member/#dismake.models.member.MemberFlags.COMPLETED_ONBOARDING","title":"COMPLETED_ONBOARDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>COMPLETED_ONBOARDING = 1 &lt;&lt; 1\n</code></pre> <p>Member has completed onboarding (false)</p>"},{"location":"api/models/member/#dismake.models.member.MemberFlags.DID_REJOIN","title":"DID_REJOIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DID_REJOIN = 1 &lt;&lt; 0\n</code></pre> <p>Member has left and rejoined the guild (false)</p>"},{"location":"api/models/member/#dismake.models.member.MemberFlags.STARTED_ONBOARDING","title":"STARTED_ONBOARDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STARTED_ONBOARDING = 1 &lt;&lt; 3\n</code></pre> <p>Member has started onboarding (false)</p>"},{"location":"api/models/role/","title":"Role","text":""},{"location":"api/models/role/#dismake.models.role.PartialRole","title":"PartialRole","text":"<p>Represents a Partial Role</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>The client application that models may use for procedures.</p> required <code>id</code> <code>int</code> <p>The unique ID of the role.</p> required <p>Attributes:</p> Name Type Description <code>client</code> <code>Client</code> <p>The client application that models may use for procedures.</p> <code>id</code> <code>int</code> <p>The unique ID of the role.</p> Source code in <code>dismake/models/role.py</code> <pre><code>class PartialRole:\n\"\"\"Represents a Partial Role\n\n    Parameters\n    ----------\n    client: Client\n        The client application that models may use for procedures.\n    id: int\n        The unique ID of the role.\n\n    Attributes\n    ----------\n    client: Client\n        The client application that models may use for procedures.\n    id: int\n        The unique ID of the role.\n    \"\"\"\n\n    def __init__(self, client: Client, id: int) -&gt; None:\n        self.client = client\n        self.id = id\n\n    @property\n    def mention(self) -&gt; str:\n\"\"\"Return a raw mention string for the role.\"\"\"\n        return f\"&lt;&amp;@{self.id}&gt;\"\n</code></pre>"},{"location":"api/models/role/#dismake.models.role.PartialRole.mention","title":"mention  <code>property</code>","text":"<pre><code>mention: str\n</code></pre> <p>Return a raw mention string for the role.</p>"},{"location":"api/models/role/#dismake.models.role.Role","title":"Role","text":"<p>             Bases: <code>PartialRole</code></p> <p>Represents a Role.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>The client application that models may use for procedures.</p> required <code>data</code> <code>RoleData</code> <p>The data payload containing role information.</p> required <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the role.</p> <code>color</code> <code>int</code> <p>The color code of the role.</p> <code>hoist</code> <code>bool</code> <p>Whether the role is hoisted.</p> <code>unicode_emoji</code> <code>Optional[str]</code> <p>The Unicode emoji associated with the role.</p> <code>position</code> <code>int</code> <p>The position of the role.</p> <code>permissions</code> <code>Permissions</code> <p>The permissions granted to the role.</p> <code>managed</code> <code>bool</code> <p>Whether the role is managed.</p> <code>mentionable</code> <code>bool</code> <p>Whether the role is mentionable.</p>"},{"location":"api/models/role/#dismake.models.role.Role--operations","title":"Operations","text":"<ul> <li> <p><code>x == y</code>:     Checks if two roles are equal.</p> </li> <li> <p><code>x != y</code>:     Checks if two roles are not equal.</p> </li> <li> <p><code>str(x)</code>:     Returns the role's name.</p> </li> </ul> Source code in <code>dismake/models/role.py</code> <pre><code>class Role(PartialRole):\n\"\"\"Represents a Role.\n\n    Parameters\n    ----------\n    client: Client\n        The client application that models may use for procedures.\n    data: RoleData\n        The data payload containing role information.\n\n    Attributes\n    ----------\n    name: str\n        The name of the role.\n    color: int\n        The color code of the role.\n    hoist: bool\n        Whether the role is hoisted.\n    unicode_emoji: Optional[str]\n        The Unicode emoji associated with the role.\n    position: int\n        The position of the role.\n    permissions: Permissions\n        The permissions granted to the role.\n    managed: bool\n        Whether the role is managed.\n    mentionable: bool\n        Whether the role is mentionable.\n\n    Operations\n    ----------\n    - ``x == y``:\n        Checks if two roles are equal.\n\n    - ``x != y``:\n        Checks if two roles are not equal.\n\n    - ``str(x)``:\n        Returns the role's name.\n\n    \"\"\"\n\n    def __init__(self, client: Client, data: RoleData) -&gt; None:\n        super().__init__(client=client, id=int(data[\"id\"]))\n        self.name: str = data[\"name\"]\n        self.color: Color = Color(data[\"color\"])\n        self.hoist: bool = data[\"hoist\"]\n        self._icon: Optional[str] = data.get(\"icon\")\n        self.unicode_emoji: Optional[str] = data.get(\"unicode_emoji\")\n        self.position: int = data[\"position\"]\n        self.permissions: Permissions = Permissions(int(data[\"permissions\"]))\n        self.managed: bool = data[\"managed\"]\n        self.mentionable: bool = data[\"mentionable\"]\n        self.guild_id: int\n        # self.flags: int = data[\"flags\"]\n        self._tags: Union[RoleTagsData, Dict[Any, Any]] = data.get(\"tags\") or {}\n\n    def __eq__(self, other: Any) -&gt; bool:\n        return isinstance(other, Role) and self.id == other.id\n\n    def __ne__(self, other: Any) -&gt; bool:\n        return not self.__eq__(other)\n\n    def __str__(self) -&gt; str:\n        return f\"Role(id={self.id}, name={self.name})\"\n\n    @property\n    def created_at(self) -&gt; datetime:\n\"\"\"Returns the role's creation time in UTC.\"\"\"\n        return snowflake_time(self.id)\n    @property\n    def icon(self) -&gt; Optional[Asset]:\n\"\"\"Returns the role's icon asset, if available.\n\n        If this is ``None``, the role might instead have unicode emoji as its icon\n        If you want the icon that a role has displayed, consider using ``Role.display_icon``.\n        \"\"\"\n        return Asset.from_icon(self.id, self._icon, path='role') if self._icon is not None else None\n    @property\n    def display_icon(self) -&gt; Optional[Union[Asset, str]]:\n\"\"\"Returns the role's display icon, if available.\"\"\"\n        return self.icon or self.unicode_emoji\n\n    @property\n    def bot_id(self) -&gt; Optional[int]:\n\"\"\"The ID of the bot this role belongs to.\"\"\"\n        bot_id = self._tags.get(\"bot_id\")\n        return int(bot_id) if bot_id is not None else None\n\n    @property\n    def integration_id(self) -&gt; Optional[int]:\n\"\"\"The ID of the integration this role belongs to.\"\"\"\n        integration_id = self._tags.get(\"integration_id\")\n        return int(integration_id) if integration_id is not None else None\n\n    @property\n    def is_premium_subscriber(self) -&gt; bool:\n\"\"\"Whether this role is the guild's nitro subscriber role.\"\"\"\n        return \"premium_subscriber\" in self._tags\n\n    @property\n    def is_available_for_purchase(self) -&gt; bool:\n\"\"\"Whether this role is available for purchase.\"\"\"\n        return \"available_for_purchase\" in self._tags\n\n    @property\n    def is_guild_linked_role(self) -&gt; bool:\n\"\"\"Whether this role is a linked role in the guild.\"\"\"\n        return \"guild_connections\" in self._tags\n\n    @property\n    def subscription_listing_id(self) -&gt; Optional[int]:\n\"\"\"The ID of this role's subscription SKU and listing.\"\"\"\n        subscription_listing_id = self._tags.get(\"subscription_listing_id\")\n        return (\n            int(subscription_listing_id)\n            if subscription_listing_id is not None\n            else None\n        )\n</code></pre>"},{"location":"api/models/role/#dismake.models.role.Role.bot_id","title":"bot_id  <code>property</code>","text":"<pre><code>bot_id: Optional[int]\n</code></pre> <p>The ID of the bot this role belongs to.</p>"},{"location":"api/models/role/#dismake.models.role.Role.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>Returns the role's creation time in UTC.</p>"},{"location":"api/models/role/#dismake.models.role.Role.display_icon","title":"display_icon  <code>property</code>","text":"<pre><code>display_icon: Optional[Union[Asset, str]]\n</code></pre> <p>Returns the role's display icon, if available.</p>"},{"location":"api/models/role/#dismake.models.role.Role.icon","title":"icon  <code>property</code>","text":"<pre><code>icon: Optional[Asset]\n</code></pre> <p>Returns the role's icon asset, if available.</p> <p>If this is <code>None</code>, the role might instead have unicode emoji as its icon If you want the icon that a role has displayed, consider using <code>Role.display_icon</code>.</p>"},{"location":"api/models/role/#dismake.models.role.Role.integration_id","title":"integration_id  <code>property</code>","text":"<pre><code>integration_id: Optional[int]\n</code></pre> <p>The ID of the integration this role belongs to.</p>"},{"location":"api/models/role/#dismake.models.role.Role.is_available_for_purchase","title":"is_available_for_purchase  <code>property</code>","text":"<pre><code>is_available_for_purchase: bool\n</code></pre> <p>Whether this role is available for purchase.</p>"},{"location":"api/models/role/#dismake.models.role.Role.is_guild_linked_role","title":"is_guild_linked_role  <code>property</code>","text":"<pre><code>is_guild_linked_role: bool\n</code></pre> <p>Whether this role is a linked role in the guild.</p>"},{"location":"api/models/role/#dismake.models.role.Role.is_premium_subscriber","title":"is_premium_subscriber  <code>property</code>","text":"<pre><code>is_premium_subscriber: bool\n</code></pre> <p>Whether this role is the guild's nitro subscriber role.</p>"},{"location":"api/models/role/#dismake.models.role.Role.subscription_listing_id","title":"subscription_listing_id  <code>property</code>","text":"<pre><code>subscription_listing_id: Optional[int]\n</code></pre> <p>The ID of this role's subscription SKU and listing.</p>"},{"location":"api/models/user/","title":"User","text":""},{"location":"api/models/user/#dismake.models.user.PartialUser","title":"PartialUser","text":"<p>Represents a Partial User</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>The client application that models may use for procedures.</p> required <code>id</code> <code>int</code> <p>The unique ID of the user.</p> required <p>Attributes:</p> Name Type Description <code>client</code> <code>Client</code> <p>The client application that models may use for procedures.</p> <code>id</code> <code>int</code> <p>The unique ID of the user.</p> Source code in <code>dismake/models/user.py</code> <pre><code>class PartialUser:\n\"\"\"Represents a Partial User\n\n    Parameters\n    ----------\n    client: Client\n        The client application that models may use for procedures.\n    id: int\n        The unique ID of the user.\n\n    Attributes\n    ----------\n    client: Client\n        The client application that models may use for procedures.\n    id: int\n        The unique ID of the user.\n    \"\"\"\n\n    def __init__(self, client: Client, id: int) -&gt; None:\n        self.client = client\n        self.id = id\n\n    @property\n    def mention(self) -&gt; str:\n\"\"\"Return a raw mention string for the user.\"\"\"\n        return f\"&lt;@{self.id}&gt;\"\n</code></pre>"},{"location":"api/models/user/#dismake.models.user.PartialUser.mention","title":"mention  <code>property</code>","text":"<pre><code>mention: str\n</code></pre> <p>Return a raw mention string for the user.</p>"},{"location":"api/models/user/#dismake.models.user.User","title":"User","text":"<p>             Bases: <code>PartialUser</code></p> <p>Represents a Discord user.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>The client application that models may use for procedures.</p> required <code>data</code> <code>UserData</code> <p>The data payload containing user information.</p> required <p>Attributes:</p> Name Type Description <code>username</code> <code>str</code> <p>The username of the user.</p> <code>discriminator</code> <code>str</code> <p>The discriminator of the user. (Legacy concept)</p> <code>global_name</code> <code>Optional[str]</code> <p>The user's global nickname, taking precedence over the username in display.</p> <code>bot</code> <code>bool</code> <p>Indicates whether the user is a bot account.</p> <code>system</code> <code>bool</code> <p>Indicates whether the user represents Discord officially (system user).</p> <code>mfa_enabled</code> <code>bool</code> <p>Indicates whether two-factor authentication is enabled for the user.</p> <code>accent_color</code> <code>Optional[Colortfgv]</code> <p>The user's accent color if present; otherwise, None.</p> <code>locale</code> <code>str</code> <p>The user's locale.</p> <code>verified</code> <code>bool</code> <p>Indicates whether the user is verified.</p> <code>email</code> <code>Optional[str]</code> <p>The user's email address, if available.</p> <code>flags</code> <code>UserFlag</code> <p>Flags associated with the user.</p> <code>premium_type</code> <code>PremiumType</code> <p>The user's premium type.</p> <code>avatar_decoration</code> <code>str</code> <p>The hash of the user's avatar decoration.</p>"},{"location":"api/models/user/#dismake.models.user.User--operations","title":"Operations","text":"<ul> <li> <p><code>x == y</code>:     Checks if two users are equal.</p> </li> <li> <p><code>x != y</code>:     Checks if two users are not equal.</p> </li> <li> <p><code>str(x)</code>:     Returns the username.</p> </li> </ul> Source code in <code>dismake/models/user.py</code> <pre><code>class User(PartialUser):\n\"\"\"Represents a Discord user.\n\n    Parameters\n    ----------\n    client: Client\n        The client application that models may use for procedures.\n    data: UserData\n        The data payload containing user information.\n\n    Attributes\n    ----------\n    username: str\n        The username of the user.\n    discriminator: str\n        The discriminator of the user. (Legacy concept)\n    global_name: Optional[str]\n        The user's global nickname, taking precedence over the username in display.\n    bot: bool\n        Indicates whether the user is a bot account.\n    system: bool\n        Indicates whether the user represents Discord officially (system user).\n    mfa_enabled: bool\n        Indicates whether two-factor authentication is enabled for the user.\n    accent_color: Optional[Colortfgv]\n        The user's accent color if present; otherwise, None.\n    locale: str\n        The user's locale.\n    verified: bool\n        Indicates whether the user is verified.\n    email: Optional[str]\n        The user's email address, if available.\n    flags: UserFlag\n        Flags associated with the user.\n    premium_type: PremiumType\n        The user's premium type.\n    avatar_decoration: str\n        The hash of the user's avatar decoration.\n\n    Operations\n    ----------\n    - ``x == y``:\n        Checks if two users are equal.\n\n    - ``x != y``:\n        Checks if two users are not equal.\n\n    - ``str(x)``:\n        Returns the username.\n\n    \"\"\"\n\n    __slots__: Tuple[str, ...] = (\n        \"username\",\n        \"discriminator\",\n        \"global_name\",\n        \"_avatar\",\n        \"bot\",\n        \"system\",\n        \"mfa_enabled\",\n        \"_banner\",\n        \"accent_color\",\n        \"locale\",\n        \"verified\",\n        \"email\",\n        \"public_flags\",\n        \"premium_type\",\n        \"avatar_decoration\",\n    )\n\n    def __init__(self, client: Client, data: UserData) -&gt; None:\n        super().__init__(client=client, id=int(data[\"id\"]))\n        self.username: str = data[\"username\"]\n        self.discriminator: str = data[\"discriminator\"]\n        self.global_name: Optional[str] = data.get(\"global_name\")\n        self._avatar: Optional[str] = data.get(\"avatar\")\n        self.bot: bool = data[\"bot\"]\n        self.system: bool = data[\"system\"]\n        self.mfa_enabled: bool = data[\"mfa_enabled\"]\n        self._banner: Optional[str] = data.get(\"banner\")\n        self.accent_color: Optional[Color] = (\n            Color(value) if (value := data.get(\"accent_color\")) is not None else None\n        )\n        self.locale: str = data[\"locale\"]\n        self.verified: bool = data[\"verified\"]\n        self.email: Optional[str] = data.get(\"email\")\n        self.public_flags: PublicUserFlags = PublicUserFlags(int(data.get(\"flags\", 0)))\n        self.premium_type: PremiumType = PremiumType(int(data[\"premium_type\"]))\n        self.avatar_decoration: str = data[\"avatar_decoration\"]\n\n    def __str__(self) -&gt; str:\n        return self.username\n\n    def __repr__(self) -&gt; str:\n        return f\"User(id={self.id}, username={self.username})\"\n\n    def __eq__(self, other: Any) -&gt; bool:\n        return isinstance(other, User) and self.id == other.id\n\n    def __ne__(self, other: Any) -&gt; bool:\n        return not self.__eq__(other)\n\n    @property\n    def avatar(self) -&gt; Optional[Asset]:\n\"\"\"Returns an ``Asset`` for the avatar the user has.\n\n        If the user has not uploaded a global avatar, ``None`` is returned.\n        \"\"\"\n        if self._avatar is not None:\n            return Asset.from_avatar(self.id, self._avatar)\n        return None\n    @property\n    def default_avatar(self) -&gt; Asset:\n\"\"\"Returns the default avatar for a given user.\"\"\"\n        if self.discriminator == '0':\n            avatar_id = (self.id &gt;&gt; 22) % len(DefaultAvatar)\n        else:\n            avatar_id = int(self.discriminator) % 5\n\n        return Asset.from_default_avatar(avatar_id)\n\n    @property\n    def display_avatar(self) -&gt; Asset:\n\"\"\"Returns the user's display avatar.\n\n        For regular users this is just their default avatar or uploaded avatar.\n        \"\"\"\n        return self.avatar or self.default_avatar   \n\n    @property\n    def banner(self) -&gt; Optional[Asset]:\n\"\"\"Returns the user's banner asset, if available.\"\"\"\n        if self._banner is None:\n            return None\n        return Asset.from_user_banner(self.id, self._banner)\n</code></pre>"},{"location":"api/models/user/#dismake.models.user.User.avatar","title":"avatar  <code>property</code>","text":"<pre><code>avatar: Optional[Asset]\n</code></pre> <p>Returns an <code>Asset</code> for the avatar the user has.</p> <p>If the user has not uploaded a global avatar, <code>None</code> is returned.</p>"},{"location":"api/models/user/#dismake.models.user.User.banner","title":"banner  <code>property</code>","text":"<pre><code>banner: Optional[Asset]\n</code></pre> <p>Returns the user's banner asset, if available.</p>"},{"location":"api/models/user/#dismake.models.user.User.default_avatar","title":"default_avatar  <code>property</code>","text":"<pre><code>default_avatar: Asset\n</code></pre> <p>Returns the default avatar for a given user.</p>"},{"location":"api/models/user/#dismake.models.user.User.display_avatar","title":"display_avatar  <code>property</code>","text":"<pre><code>display_avatar: Asset\n</code></pre> <p>Returns the user's display avatar.</p> <p>For regular users this is just their default avatar or uploaded avatar.</p>"},{"location":"api/models/user/#dismake.models.user.PublicUserFlags","title":"PublicUserFlags","text":"<p>             Bases: <code>IntFlag</code></p> <p>The known user flags that represent account badges.</p> Source code in <code>dismake/models/user.py</code> <pre><code>class PublicUserFlags(IntFlag):\n\"\"\"The known user flags that represent account badges.\"\"\"\n\n    NONE = 0\n\"\"\"None.\"\"\"\n\n    DISCORD_EMPLOYEE = 1 &lt;&lt; 0\n\"\"\"Discord Employee.\"\"\"\n\n    PARTNERED_SERVER_OWNER = 1 &lt;&lt; 1\n\"\"\"Owner of a partnered Discord server.\"\"\"\n\n    HYPESQUAD_EVENTS = 1 &lt;&lt; 2\n\"\"\"HypeSquad Events.\"\"\"\n\n    BUG_HUNTER_LEVEL_1 = 1 &lt;&lt; 3\n\"\"\"Bug Hunter Level 1.\"\"\"\n\n    HYPESQUAD_BRAVERY = 1 &lt;&lt; 6\n\"\"\"House of Bravery.\"\"\"\n\n    HYPESQUAD_BRILLIANCE = 1 &lt;&lt; 7\n\"\"\"House of Brilliance.\"\"\"\n\n    HYPESQUAD_BALANCE = 1 &lt;&lt; 8\n\"\"\"House of Balance.\"\"\"\n\n    EARLY_SUPPORTER = 1 &lt;&lt; 9\n\"\"\"Early Supporter.\"\"\"\n\n    TEAM_USER = 1 &lt;&lt; 10\n\"\"\"Team user.\"\"\"\n\n    BUG_HUNTER_LEVEL_2 = 1 &lt;&lt; 14\n\"\"\"Bug Hunter Level 2.\"\"\"\n\n    VERIFIED_BOT = 1 &lt;&lt; 16\n\"\"\"Verified Bot.\"\"\"\n\n    EARLY_VERIFIED_DEVELOPER = 1 &lt;&lt; 17\n\"\"\"Early verified Bot Developer.\n\n    Only applies to users that verified their account before 20th August 2019.\n    \"\"\"\n\n    DISCORD_CERTIFIED_MODERATOR = 1 &lt;&lt; 18\n\"\"\"Discord Certified Moderator.\"\"\"\n\n    BOT_HTTP_INTERACTIONS = 1 &lt;&lt; 19\n\"\"\"Bot uses only HTTP interactions and is shown in the active member list.\"\"\"\n\n    ACTIVE_DEVELOPER = 1 &lt;&lt; 22\n\"\"\"User is an active bot developer.\"\"\"\n</code></pre>"},{"location":"api/models/user/#dismake.models.user.PublicUserFlags.ACTIVE_DEVELOPER","title":"ACTIVE_DEVELOPER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_DEVELOPER = 1 &lt;&lt; 22\n</code></pre> <p>User is an active bot developer.</p>"},{"location":"api/models/user/#dismake.models.user.PublicUserFlags.BOT_HTTP_INTERACTIONS","title":"BOT_HTTP_INTERACTIONS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BOT_HTTP_INTERACTIONS = 1 &lt;&lt; 19\n</code></pre> <p>Bot uses only HTTP interactions and is shown in the active member list.</p>"},{"location":"api/models/user/#dismake.models.user.PublicUserFlags.BUG_HUNTER_LEVEL_1","title":"BUG_HUNTER_LEVEL_1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BUG_HUNTER_LEVEL_1 = 1 &lt;&lt; 3\n</code></pre> <p>Bug Hunter Level 1.</p>"},{"location":"api/models/user/#dismake.models.user.PublicUserFlags.BUG_HUNTER_LEVEL_2","title":"BUG_HUNTER_LEVEL_2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BUG_HUNTER_LEVEL_2 = 1 &lt;&lt; 14\n</code></pre> <p>Bug Hunter Level 2.</p>"},{"location":"api/models/user/#dismake.models.user.PublicUserFlags.DISCORD_CERTIFIED_MODERATOR","title":"DISCORD_CERTIFIED_MODERATOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISCORD_CERTIFIED_MODERATOR = 1 &lt;&lt; 18\n</code></pre> <p>Discord Certified Moderator.</p>"},{"location":"api/models/user/#dismake.models.user.PublicUserFlags.DISCORD_EMPLOYEE","title":"DISCORD_EMPLOYEE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISCORD_EMPLOYEE = 1 &lt;&lt; 0\n</code></pre> <p>Discord Employee.</p>"},{"location":"api/models/user/#dismake.models.user.PublicUserFlags.EARLY_SUPPORTER","title":"EARLY_SUPPORTER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EARLY_SUPPORTER = 1 &lt;&lt; 9\n</code></pre> <p>Early Supporter.</p>"},{"location":"api/models/user/#dismake.models.user.PublicUserFlags.EARLY_VERIFIED_DEVELOPER","title":"EARLY_VERIFIED_DEVELOPER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EARLY_VERIFIED_DEVELOPER = 1 &lt;&lt; 17\n</code></pre> <p>Early verified Bot Developer.</p> <p>Only applies to users that verified their account before 20th August 2019.</p>"},{"location":"api/models/user/#dismake.models.user.PublicUserFlags.HYPESQUAD_BALANCE","title":"HYPESQUAD_BALANCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HYPESQUAD_BALANCE = 1 &lt;&lt; 8\n</code></pre> <p>House of Balance.</p>"},{"location":"api/models/user/#dismake.models.user.PublicUserFlags.HYPESQUAD_BRAVERY","title":"HYPESQUAD_BRAVERY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HYPESQUAD_BRAVERY = 1 &lt;&lt; 6\n</code></pre> <p>House of Bravery.</p>"},{"location":"api/models/user/#dismake.models.user.PublicUserFlags.HYPESQUAD_BRILLIANCE","title":"HYPESQUAD_BRILLIANCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HYPESQUAD_BRILLIANCE = 1 &lt;&lt; 7\n</code></pre> <p>House of Brilliance.</p>"},{"location":"api/models/user/#dismake.models.user.PublicUserFlags.HYPESQUAD_EVENTS","title":"HYPESQUAD_EVENTS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HYPESQUAD_EVENTS = 1 &lt;&lt; 2\n</code></pre> <p>HypeSquad Events.</p>"},{"location":"api/models/user/#dismake.models.user.PublicUserFlags.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = 0\n</code></pre> <p>None.</p>"},{"location":"api/models/user/#dismake.models.user.PublicUserFlags.PARTNERED_SERVER_OWNER","title":"PARTNERED_SERVER_OWNER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PARTNERED_SERVER_OWNER = 1 &lt;&lt; 1\n</code></pre> <p>Owner of a partnered Discord server.</p>"},{"location":"api/models/user/#dismake.models.user.PublicUserFlags.TEAM_USER","title":"TEAM_USER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TEAM_USER = 1 &lt;&lt; 10\n</code></pre> <p>Team user.</p>"},{"location":"api/models/user/#dismake.models.user.PublicUserFlags.VERIFIED_BOT","title":"VERIFIED_BOT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VERIFIED_BOT = 1 &lt;&lt; 16\n</code></pre> <p>Verified Bot.</p>"},{"location":"api/models/user/#dismake.models.user.PremiumType","title":"PremiumType","text":"<p>             Bases: <code>IntEnum</code></p> <p>The types of Nitro.</p> Source code in <code>dismake/models/user.py</code> <pre><code>class PremiumType(IntEnum):\n\"\"\"The types of Nitro.\"\"\"\n\n    NONE = 0\n\"\"\"No premium.\"\"\"\n\n    NITRO_CLASSIC = 1\n\"\"\"Premium including basic perks like animated emojis and avatars.\"\"\"\n\n    NITRO = 2\n\"\"\"Premium including all perks (e.g. 2 server boosts).\"\"\"\n</code></pre>"},{"location":"api/models/user/#dismake.models.user.PremiumType.NITRO","title":"NITRO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NITRO = 2\n</code></pre> <p>Premium including all perks (e.g. 2 server boosts).</p>"},{"location":"api/models/user/#dismake.models.user.PremiumType.NITRO_CLASSIC","title":"NITRO_CLASSIC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NITRO_CLASSIC = 1\n</code></pre> <p>Premium including basic perks like animated emojis and avatars.</p>"},{"location":"api/models/user/#dismake.models.user.PremiumType.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = 0\n</code></pre> <p>No premium.</p>"}]}